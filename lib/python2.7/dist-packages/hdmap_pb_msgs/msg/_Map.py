# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from hdmap_pb_msgs/Map.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import hdmap_pb_msgs.msg

class Map(genpy.Message):
  _md5sum = "83626360938f309d85beab03f51d0bb3"
  _type = "hdmap_pb_msgs/Map"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """hdmap_pb_msgs/Header header 
Crosswalk[] crosswalk 
Junction[] junction 
Lane[] lane 
StopSign[] stop_sign 
Signal[] signal 
YieldSign[] yieldX 
Overlap[] overlap 

================================================================================
MSG: hdmap_pb_msgs/Header
int8 version 
int8 date 

================================================================================
MSG: hdmap_pb_msgs/Crosswalk
Id id 
Polygon polygon 
Id[] overlap_id 

================================================================================
MSG: hdmap_pb_msgs/Id
int8 id 

================================================================================
MSG: hdmap_pb_msgs/Polygon
Point[] point 

================================================================================
MSG: hdmap_pb_msgs/Point
float64 x 
float64 y 
float64 z 

================================================================================
MSG: hdmap_pb_msgs/Junction
Id id 
Polygon polygon 
Id[] crosswalk_id 
Id[] overlap_id 
int32 num_road_segments 
Id[] lane_id 

================================================================================
MSG: hdmap_pb_msgs/Lane
Id id 
int32 type 
int32 turn 
Curve central_curve 
LaneBoundary left_boundary 
LaneBoundary right_boundary 
float64 width 
float64 length 
float64 speed_limit 
Id[] overlap_id 
Id[] predecessor_id 
Id[] successor_id 
Id[] left_neighbor_forward_lane_id 
Id[] right_neighbor_forward_lane_id 
Id[] left_neighbor_reverse_lane_id 
Id[] right_neighbor_reverse_lane_id 
Id[] stop_sign_id 
Id junction_id 
Id[] crosswalk_id 
Id[] yield_sign_id 
LaneSampleAssociation[] left_sample 
LaneSampleAssociation[] right_sample 

================================================================================
MSG: hdmap_pb_msgs/Curve
CurveSegment[] segment 

================================================================================
MSG: hdmap_pb_msgs/CurveSegment
LineSegment line_segment 
Arc arc 
Spiral spiral 
Spline spline 
Poly3 poly3 
float64 s 
Point start_position 
float64 heading 
float64 length 

================================================================================
MSG: hdmap_pb_msgs/LineSegment
Point[] point 

================================================================================
MSG: hdmap_pb_msgs/Arc
Point center 
float64 radius 
float64 start_angle 
float64 end_angle 

================================================================================
MSG: hdmap_pb_msgs/Spiral
float64 curv_start 
float64 curv_end 

================================================================================
MSG: hdmap_pb_msgs/Spline
int32 dimension 
int32 degree 
float64[] knot 
Point[] control 

================================================================================
MSG: hdmap_pb_msgs/Poly3

================================================================================
MSG: hdmap_pb_msgs/LaneBoundary
Curve curve 
int32 type 
float64 length 

================================================================================
MSG: hdmap_pb_msgs/LaneSampleAssociation
float64 s 
float64 width 

================================================================================
MSG: hdmap_pb_msgs/StopSign
Id id 
Curve stop_line 
Point location 
Id[] overlap_id 
Id signal_id 

================================================================================
MSG: hdmap_pb_msgs/Signal
Id id 
Polygon boundary 
Subsignal[] subsignal 
Id[] overlap_id 
int32 type 
Curve[] stop_line 

================================================================================
MSG: hdmap_pb_msgs/Subsignal
Id id 
int32 type 
Point location 

================================================================================
MSG: hdmap_pb_msgs/YieldSign
Id id 
Curve stop_line 
Point location 
Id[] overlap_id 

================================================================================
MSG: hdmap_pb_msgs/Overlap
Id id 
ObjectOverlapInfo[] object 

================================================================================
MSG: hdmap_pb_msgs/ObjectOverlapInfo
Id id 
LaneOverlapInfo lane_overlap_info 
SignalOverlapInfo signal_overlap_info 
StopSignOverlapInfo stop_sign_overlap_info 
CrosswalkOverlapInfo crosswalk_overlap_info 
JunctionOverlapInfo junction_overlap_info 

================================================================================
MSG: hdmap_pb_msgs/LaneOverlapInfo
float64 start_s 
float64 end_s 
bool is_merge 
bool has_precedence 

================================================================================
MSG: hdmap_pb_msgs/SignalOverlapInfo

================================================================================
MSG: hdmap_pb_msgs/StopSignOverlapInfo

================================================================================
MSG: hdmap_pb_msgs/CrosswalkOverlapInfo

================================================================================
MSG: hdmap_pb_msgs/JunctionOverlapInfo
"""
  __slots__ = ['header','crosswalk','junction','lane','stop_sign','signal','yieldX','overlap']
  _slot_types = ['hdmap_pb_msgs/Header','hdmap_pb_msgs/Crosswalk[]','hdmap_pb_msgs/Junction[]','hdmap_pb_msgs/Lane[]','hdmap_pb_msgs/StopSign[]','hdmap_pb_msgs/Signal[]','hdmap_pb_msgs/YieldSign[]','hdmap_pb_msgs/Overlap[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,crosswalk,junction,lane,stop_sign,signal,yieldX,overlap

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Map, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = hdmap_pb_msgs.msg.Header()
      if self.crosswalk is None:
        self.crosswalk = []
      if self.junction is None:
        self.junction = []
      if self.lane is None:
        self.lane = []
      if self.stop_sign is None:
        self.stop_sign = []
      if self.signal is None:
        self.signal = []
      if self.yieldX is None:
        self.yieldX = []
      if self.overlap is None:
        self.overlap = []
    else:
      self.header = hdmap_pb_msgs.msg.Header()
      self.crosswalk = []
      self.junction = []
      self.lane = []
      self.stop_sign = []
      self.signal = []
      self.yieldX = []
      self.overlap = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_2b.pack(_x.header.version, _x.header.date))
      length = len(self.crosswalk)
      buff.write(_struct_I.pack(length))
      for val1 in self.crosswalk:
        _v1 = val1.id
        buff.write(_struct_b.pack(_v1.id))
        _v2 = val1.polygon
        length = len(_v2.point)
        buff.write(_struct_I.pack(length))
        for val3 in _v2.point:
          _x = val3
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
      length = len(self.junction)
      buff.write(_struct_I.pack(length))
      for val1 in self.junction:
        _v3 = val1.id
        buff.write(_struct_b.pack(_v3.id))
        _v4 = val1.polygon
        length = len(_v4.point)
        buff.write(_struct_I.pack(length))
        for val3 in _v4.point:
          _x = val3
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.crosswalk_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.crosswalk_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        buff.write(_struct_i.pack(val1.num_road_segments))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.lane_id:
          buff.write(_struct_b.pack(val2.id))
      length = len(self.lane)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane:
        _v5 = val1.id
        buff.write(_struct_b.pack(_v5.id))
        _x = val1
        buff.write(_struct_2i.pack(_x.type, _x.turn))
        _v6 = val1.central_curve
        length = len(_v6.segment)
        buff.write(_struct_I.pack(length))
        for val3 in _v6.segment:
          _v7 = val3.line_segment
          length = len(_v7.point)
          buff.write(_struct_I.pack(length))
          for val5 in _v7.point:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v8 = val3.arc
          _v9 = _v8.center
          _x = _v9
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v8
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v10 = val3.spiral
          _x = _v10
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v11 = val3.spline
          _x = _v11
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v11.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *_v11.knot))
          length = len(_v11.control)
          buff.write(_struct_I.pack(length))
          for val5 in _v11.control:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v12 = val3.poly3
          pass
          buff.write(_struct_d.pack(val3.s))
          _v13 = val3.start_position
          _x = _v13
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val3
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _v14 = val1.left_boundary
        _v15 = _v14.curve
        length = len(_v15.segment)
        buff.write(_struct_I.pack(length))
        for val4 in _v15.segment:
          _v16 = val4.line_segment
          length = len(_v16.point)
          buff.write(_struct_I.pack(length))
          for val6 in _v16.point:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v17 = val4.arc
          _v18 = _v17.center
          _x = _v18
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v17
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v19 = val4.spiral
          _x = _v19
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v20 = val4.spline
          _x = _v20
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v20.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *_v20.knot))
          length = len(_v20.control)
          buff.write(_struct_I.pack(length))
          for val6 in _v20.control:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v21 = val4.poly3
          pass
          buff.write(_struct_d.pack(val4.s))
          _v22 = val4.start_position
          _x = _v22
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val4
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _x = _v14
        buff.write(_struct_id.pack(_x.type, _x.length))
        _v23 = val1.right_boundary
        _v24 = _v23.curve
        length = len(_v24.segment)
        buff.write(_struct_I.pack(length))
        for val4 in _v24.segment:
          _v25 = val4.line_segment
          length = len(_v25.point)
          buff.write(_struct_I.pack(length))
          for val6 in _v25.point:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v26 = val4.arc
          _v27 = _v26.center
          _x = _v27
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v26
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v28 = val4.spiral
          _x = _v28
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v29 = val4.spline
          _x = _v29
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v29.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *_v29.knot))
          length = len(_v29.control)
          buff.write(_struct_I.pack(length))
          for val6 in _v29.control:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v30 = val4.poly3
          pass
          buff.write(_struct_d.pack(val4.s))
          _v31 = val4.start_position
          _x = _v31
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val4
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _x = _v23
        buff.write(_struct_id.pack(_x.type, _x.length))
        _x = val1
        buff.write(_struct_3d.pack(_x.width, _x.length, _x.speed_limit))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.predecessor_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.predecessor_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.successor_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.successor_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.left_neighbor_forward_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_neighbor_forward_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.right_neighbor_forward_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_neighbor_forward_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.left_neighbor_reverse_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_neighbor_reverse_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.right_neighbor_reverse_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_neighbor_reverse_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.stop_sign_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.stop_sign_id:
          buff.write(_struct_b.pack(val2.id))
        _v32 = val1.junction_id
        buff.write(_struct_b.pack(_v32.id))
        length = len(val1.crosswalk_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.crosswalk_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.yield_sign_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.yield_sign_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.left_sample)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_sample:
          _x = val2
          buff.write(_struct_2d.pack(_x.s, _x.width))
        length = len(val1.right_sample)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_sample:
          _x = val2
          buff.write(_struct_2d.pack(_x.s, _x.width))
      length = len(self.stop_sign)
      buff.write(_struct_I.pack(length))
      for val1 in self.stop_sign:
        _v33 = val1.id
        buff.write(_struct_b.pack(_v33.id))
        _v34 = val1.stop_line
        length = len(_v34.segment)
        buff.write(_struct_I.pack(length))
        for val3 in _v34.segment:
          _v35 = val3.line_segment
          length = len(_v35.point)
          buff.write(_struct_I.pack(length))
          for val5 in _v35.point:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v36 = val3.arc
          _v37 = _v36.center
          _x = _v37
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v36
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v38 = val3.spiral
          _x = _v38
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v39 = val3.spline
          _x = _v39
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v39.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *_v39.knot))
          length = len(_v39.control)
          buff.write(_struct_I.pack(length))
          for val5 in _v39.control:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v40 = val3.poly3
          pass
          buff.write(_struct_d.pack(val3.s))
          _v41 = val3.start_position
          _x = _v41
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val3
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _v42 = val1.location
        _x = _v42
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        _v43 = val1.signal_id
        buff.write(_struct_b.pack(_v43.id))
      length = len(self.signal)
      buff.write(_struct_I.pack(length))
      for val1 in self.signal:
        _v44 = val1.id
        buff.write(_struct_b.pack(_v44.id))
        _v45 = val1.boundary
        length = len(_v45.point)
        buff.write(_struct_I.pack(length))
        for val3 in _v45.point:
          _x = val3
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.subsignal)
        buff.write(_struct_I.pack(length))
        for val2 in val1.subsignal:
          _v46 = val2.id
          buff.write(_struct_b.pack(_v46.id))
          buff.write(_struct_i.pack(val2.type))
          _v47 = val2.location
          _x = _v47
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        buff.write(_struct_i.pack(val1.type))
        length = len(val1.stop_line)
        buff.write(_struct_I.pack(length))
        for val2 in val1.stop_line:
          length = len(val2.segment)
          buff.write(_struct_I.pack(length))
          for val3 in val2.segment:
            _v48 = val3.line_segment
            length = len(_v48.point)
            buff.write(_struct_I.pack(length))
            for val5 in _v48.point:
              _x = val5
              buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v49 = val3.arc
            _v50 = _v49.center
            _x = _v50
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _x = _v49
            buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
            _v51 = val3.spiral
            _x = _v51
            buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
            _v52 = val3.spline
            _x = _v52
            buff.write(_struct_2i.pack(_x.dimension, _x.degree))
            length = len(_v52.knot)
            buff.write(_struct_I.pack(length))
            pattern = '<%sd'%length
            buff.write(struct.pack(pattern, *_v52.knot))
            length = len(_v52.control)
            buff.write(_struct_I.pack(length))
            for val5 in _v52.control:
              _x = val5
              buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v53 = val3.poly3
            pass
            buff.write(_struct_d.pack(val3.s))
            _v54 = val3.start_position
            _x = _v54
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _x = val3
            buff.write(_struct_2d.pack(_x.heading, _x.length))
      length = len(self.yieldX)
      buff.write(_struct_I.pack(length))
      for val1 in self.yieldX:
        _v55 = val1.id
        buff.write(_struct_b.pack(_v55.id))
        _v56 = val1.stop_line
        length = len(_v56.segment)
        buff.write(_struct_I.pack(length))
        for val3 in _v56.segment:
          _v57 = val3.line_segment
          length = len(_v57.point)
          buff.write(_struct_I.pack(length))
          for val5 in _v57.point:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v58 = val3.arc
          _v59 = _v58.center
          _x = _v59
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v58
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v60 = val3.spiral
          _x = _v60
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v61 = val3.spline
          _x = _v61
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v61.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.pack(pattern, *_v61.knot))
          length = len(_v61.control)
          buff.write(_struct_I.pack(length))
          for val5 in _v61.control:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v62 = val3.poly3
          pass
          buff.write(_struct_d.pack(val3.s))
          _v63 = val3.start_position
          _x = _v63
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val3
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _v64 = val1.location
        _x = _v64
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
      length = len(self.overlap)
      buff.write(_struct_I.pack(length))
      for val1 in self.overlap:
        _v65 = val1.id
        buff.write(_struct_b.pack(_v65.id))
        length = len(val1.object)
        buff.write(_struct_I.pack(length))
        for val2 in val1.object:
          _v66 = val2.id
          buff.write(_struct_b.pack(_v66.id))
          _v67 = val2.lane_overlap_info
          _x = _v67
          buff.write(_struct_2d2B.pack(_x.start_s, _x.end_s, _x.is_merge, _x.has_precedence))
          _v68 = val2.signal_overlap_info
          pass
          _v69 = val2.stop_sign_overlap_info
          pass
          _v70 = val2.crosswalk_overlap_info
          pass
          _v71 = val2.junction_overlap_info
          pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = hdmap_pb_msgs.msg.Header()
      if self.crosswalk is None:
        self.crosswalk = None
      if self.junction is None:
        self.junction = None
      if self.lane is None:
        self.lane = None
      if self.stop_sign is None:
        self.stop_sign = None
      if self.signal is None:
        self.signal = None
      if self.yieldX is None:
        self.yieldX = None
      if self.overlap is None:
        self.overlap = None
      end = 0
      _x = self
      start = end
      end += 2
      (_x.header.version, _x.header.date,) = _struct_2b.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.crosswalk = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Crosswalk()
        _v72 = val1.id
        start = end
        end += 1
        (_v72.id,) = _struct_b.unpack(str[start:end])
        _v73 = val1.polygon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v73.point = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.Point()
          _x = val3
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v73.point.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        self.crosswalk.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.junction = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Junction()
        _v74 = val1.id
        start = end
        end += 1
        (_v74.id,) = _struct_b.unpack(str[start:end])
        _v75 = val1.polygon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v75.point = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.Point()
          _x = val3
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v75.point.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.crosswalk_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.crosswalk_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        start = end
        end += 4
        (val1.num_road_segments,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.lane_id.append(val2)
        self.junction.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Lane()
        _v76 = val1.id
        start = end
        end += 1
        (_v76.id,) = _struct_b.unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.type, _x.turn,) = _struct_2i.unpack(str[start:end])
        _v77 = val1.central_curve
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v77.segment = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.CurveSegment()
          _v78 = val3.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v78.point = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v78.point.append(val5)
          _v79 = val3.arc
          _v80 = _v79.center
          _x = _v80
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v79
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v81 = val3.spiral
          _x = _v81
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v82 = val3.spline
          _x = _v82
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v82.knot = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v82.control = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v82.control.append(val5)
          _v83 = val3.poly3
          start = end
          end += 8
          (val3.s,) = _struct_d.unpack(str[start:end])
          _v84 = val3.start_position
          _x = _v84
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val3
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v77.segment.append(val3)
        _v85 = val1.left_boundary
        _v86 = _v85.curve
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v86.segment = []
        for i in range(0, length):
          val4 = hdmap_pb_msgs.msg.CurveSegment()
          _v87 = val4.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v87.point = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v87.point.append(val6)
          _v88 = val4.arc
          _v89 = _v88.center
          _x = _v89
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v88
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v90 = val4.spiral
          _x = _v90
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v91 = val4.spline
          _x = _v91
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v91.knot = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v91.control = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v91.control.append(val6)
          _v92 = val4.poly3
          start = end
          end += 8
          (val4.s,) = _struct_d.unpack(str[start:end])
          _v93 = val4.start_position
          _x = _v93
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val4
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v86.segment.append(val4)
        _x = _v85
        start = end
        end += 12
        (_x.type, _x.length,) = _struct_id.unpack(str[start:end])
        _v94 = val1.right_boundary
        _v95 = _v94.curve
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v95.segment = []
        for i in range(0, length):
          val4 = hdmap_pb_msgs.msg.CurveSegment()
          _v96 = val4.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v96.point = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v96.point.append(val6)
          _v97 = val4.arc
          _v98 = _v97.center
          _x = _v98
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v97
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v99 = val4.spiral
          _x = _v99
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v100 = val4.spline
          _x = _v100
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v100.knot = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v100.control = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v100.control.append(val6)
          _v101 = val4.poly3
          start = end
          end += 8
          (val4.s,) = _struct_d.unpack(str[start:end])
          _v102 = val4.start_position
          _x = _v102
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val4
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v95.segment.append(val4)
        _x = _v94
        start = end
        end += 12
        (_x.type, _x.length,) = _struct_id.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.width, _x.length, _x.speed_limit,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.predecessor_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.predecessor_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.successor_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.successor_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_neighbor_forward_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.left_neighbor_forward_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_neighbor_forward_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.right_neighbor_forward_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_neighbor_reverse_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.left_neighbor_reverse_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_neighbor_reverse_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.right_neighbor_reverse_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.stop_sign_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.stop_sign_id.append(val2)
        _v103 = val1.junction_id
        start = end
        end += 1
        (_v103.id,) = _struct_b.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.crosswalk_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.crosswalk_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.yield_sign_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.yield_sign_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_sample = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.LaneSampleAssociation()
          _x = val2
          start = end
          end += 16
          (_x.s, _x.width,) = _struct_2d.unpack(str[start:end])
          val1.left_sample.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_sample = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.LaneSampleAssociation()
          _x = val2
          start = end
          end += 16
          (_x.s, _x.width,) = _struct_2d.unpack(str[start:end])
          val1.right_sample.append(val2)
        self.lane.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stop_sign = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.StopSign()
        _v104 = val1.id
        start = end
        end += 1
        (_v104.id,) = _struct_b.unpack(str[start:end])
        _v105 = val1.stop_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v105.segment = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.CurveSegment()
          _v106 = val3.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v106.point = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v106.point.append(val5)
          _v107 = val3.arc
          _v108 = _v107.center
          _x = _v108
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v107
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v109 = val3.spiral
          _x = _v109
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v110 = val3.spline
          _x = _v110
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v110.knot = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v110.control = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v110.control.append(val5)
          _v111 = val3.poly3
          start = end
          end += 8
          (val3.s,) = _struct_d.unpack(str[start:end])
          _v112 = val3.start_position
          _x = _v112
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val3
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v105.segment.append(val3)
        _v113 = val1.location
        _x = _v113
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        _v114 = val1.signal_id
        start = end
        end += 1
        (_v114.id,) = _struct_b.unpack(str[start:end])
        self.stop_sign.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.signal = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Signal()
        _v115 = val1.id
        start = end
        end += 1
        (_v115.id,) = _struct_b.unpack(str[start:end])
        _v116 = val1.boundary
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v116.point = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.Point()
          _x = val3
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v116.point.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.subsignal = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Subsignal()
          _v117 = val2.id
          start = end
          end += 1
          (_v117.id,) = _struct_b.unpack(str[start:end])
          start = end
          end += 4
          (val2.type,) = _struct_i.unpack(str[start:end])
          _v118 = val2.location
          _x = _v118
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          val1.subsignal.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        start = end
        end += 4
        (val1.type,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.stop_line = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Curve()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.segment = []
          for i in range(0, length):
            val3 = hdmap_pb_msgs.msg.CurveSegment()
            _v119 = val3.line_segment
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v119.point = []
            for i in range(0, length):
              val5 = hdmap_pb_msgs.msg.Point()
              _x = val5
              start = end
              end += 24
              (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
              _v119.point.append(val5)
            _v120 = val3.arc
            _v121 = _v120.center
            _x = _v121
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _x = _v120
            start = end
            end += 24
            (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
            _v122 = val3.spiral
            _x = _v122
            start = end
            end += 16
            (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
            _v123 = val3.spline
            _x = _v123
            start = end
            end += 8
            (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sd'%length
            start = end
            end += struct.calcsize(pattern)
            _v123.knot = struct.unpack(pattern, str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v123.control = []
            for i in range(0, length):
              val5 = hdmap_pb_msgs.msg.Point()
              _x = val5
              start = end
              end += 24
              (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
              _v123.control.append(val5)
            _v124 = val3.poly3
            start = end
            end += 8
            (val3.s,) = _struct_d.unpack(str[start:end])
            _v125 = val3.start_position
            _x = _v125
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _x = val3
            start = end
            end += 16
            (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
            val2.segment.append(val3)
          val1.stop_line.append(val2)
        self.signal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.yieldX = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.YieldSign()
        _v126 = val1.id
        start = end
        end += 1
        (_v126.id,) = _struct_b.unpack(str[start:end])
        _v127 = val1.stop_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v127.segment = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.CurveSegment()
          _v128 = val3.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v128.point = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v128.point.append(val5)
          _v129 = val3.arc
          _v130 = _v129.center
          _x = _v130
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v129
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v131 = val3.spiral
          _x = _v131
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v132 = val3.spline
          _x = _v132
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v132.knot = struct.unpack(pattern, str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v132.control = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v132.control.append(val5)
          _v133 = val3.poly3
          start = end
          end += 8
          (val3.s,) = _struct_d.unpack(str[start:end])
          _v134 = val3.start_position
          _x = _v134
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val3
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v127.segment.append(val3)
        _v135 = val1.location
        _x = _v135
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        self.yieldX.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.overlap = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Overlap()
        _v136 = val1.id
        start = end
        end += 1
        (_v136.id,) = _struct_b.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.object = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.ObjectOverlapInfo()
          _v137 = val2.id
          start = end
          end += 1
          (_v137.id,) = _struct_b.unpack(str[start:end])
          _v138 = val2.lane_overlap_info
          _x = _v138
          start = end
          end += 18
          (_x.start_s, _x.end_s, _x.is_merge, _x.has_precedence,) = _struct_2d2B.unpack(str[start:end])
          _v138.is_merge = bool(_v138.is_merge)
          _v138.has_precedence = bool(_v138.has_precedence)
          _v139 = val2.signal_overlap_info
          _v140 = val2.stop_sign_overlap_info
          _v141 = val2.crosswalk_overlap_info
          _v142 = val2.junction_overlap_info
          val1.object.append(val2)
        self.overlap.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_2b.pack(_x.header.version, _x.header.date))
      length = len(self.crosswalk)
      buff.write(_struct_I.pack(length))
      for val1 in self.crosswalk:
        _v143 = val1.id
        buff.write(_struct_b.pack(_v143.id))
        _v144 = val1.polygon
        length = len(_v144.point)
        buff.write(_struct_I.pack(length))
        for val3 in _v144.point:
          _x = val3
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
      length = len(self.junction)
      buff.write(_struct_I.pack(length))
      for val1 in self.junction:
        _v145 = val1.id
        buff.write(_struct_b.pack(_v145.id))
        _v146 = val1.polygon
        length = len(_v146.point)
        buff.write(_struct_I.pack(length))
        for val3 in _v146.point:
          _x = val3
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.crosswalk_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.crosswalk_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        buff.write(_struct_i.pack(val1.num_road_segments))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.lane_id:
          buff.write(_struct_b.pack(val2.id))
      length = len(self.lane)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane:
        _v147 = val1.id
        buff.write(_struct_b.pack(_v147.id))
        _x = val1
        buff.write(_struct_2i.pack(_x.type, _x.turn))
        _v148 = val1.central_curve
        length = len(_v148.segment)
        buff.write(_struct_I.pack(length))
        for val3 in _v148.segment:
          _v149 = val3.line_segment
          length = len(_v149.point)
          buff.write(_struct_I.pack(length))
          for val5 in _v149.point:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v150 = val3.arc
          _v151 = _v150.center
          _x = _v151
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v150
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v152 = val3.spiral
          _x = _v152
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v153 = val3.spline
          _x = _v153
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v153.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(_v153.knot.tostring())
          length = len(_v153.control)
          buff.write(_struct_I.pack(length))
          for val5 in _v153.control:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v154 = val3.poly3
          pass
          buff.write(_struct_d.pack(val3.s))
          _v155 = val3.start_position
          _x = _v155
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val3
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _v156 = val1.left_boundary
        _v157 = _v156.curve
        length = len(_v157.segment)
        buff.write(_struct_I.pack(length))
        for val4 in _v157.segment:
          _v158 = val4.line_segment
          length = len(_v158.point)
          buff.write(_struct_I.pack(length))
          for val6 in _v158.point:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v159 = val4.arc
          _v160 = _v159.center
          _x = _v160
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v159
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v161 = val4.spiral
          _x = _v161
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v162 = val4.spline
          _x = _v162
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v162.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(_v162.knot.tostring())
          length = len(_v162.control)
          buff.write(_struct_I.pack(length))
          for val6 in _v162.control:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v163 = val4.poly3
          pass
          buff.write(_struct_d.pack(val4.s))
          _v164 = val4.start_position
          _x = _v164
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val4
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _x = _v156
        buff.write(_struct_id.pack(_x.type, _x.length))
        _v165 = val1.right_boundary
        _v166 = _v165.curve
        length = len(_v166.segment)
        buff.write(_struct_I.pack(length))
        for val4 in _v166.segment:
          _v167 = val4.line_segment
          length = len(_v167.point)
          buff.write(_struct_I.pack(length))
          for val6 in _v167.point:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v168 = val4.arc
          _v169 = _v168.center
          _x = _v169
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v168
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v170 = val4.spiral
          _x = _v170
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v171 = val4.spline
          _x = _v171
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v171.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(_v171.knot.tostring())
          length = len(_v171.control)
          buff.write(_struct_I.pack(length))
          for val6 in _v171.control:
            _x = val6
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v172 = val4.poly3
          pass
          buff.write(_struct_d.pack(val4.s))
          _v173 = val4.start_position
          _x = _v173
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val4
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _x = _v165
        buff.write(_struct_id.pack(_x.type, _x.length))
        _x = val1
        buff.write(_struct_3d.pack(_x.width, _x.length, _x.speed_limit))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.predecessor_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.predecessor_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.successor_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.successor_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.left_neighbor_forward_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_neighbor_forward_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.right_neighbor_forward_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_neighbor_forward_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.left_neighbor_reverse_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_neighbor_reverse_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.right_neighbor_reverse_lane_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_neighbor_reverse_lane_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.stop_sign_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.stop_sign_id:
          buff.write(_struct_b.pack(val2.id))
        _v174 = val1.junction_id
        buff.write(_struct_b.pack(_v174.id))
        length = len(val1.crosswalk_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.crosswalk_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.yield_sign_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.yield_sign_id:
          buff.write(_struct_b.pack(val2.id))
        length = len(val1.left_sample)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_sample:
          _x = val2
          buff.write(_struct_2d.pack(_x.s, _x.width))
        length = len(val1.right_sample)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_sample:
          _x = val2
          buff.write(_struct_2d.pack(_x.s, _x.width))
      length = len(self.stop_sign)
      buff.write(_struct_I.pack(length))
      for val1 in self.stop_sign:
        _v175 = val1.id
        buff.write(_struct_b.pack(_v175.id))
        _v176 = val1.stop_line
        length = len(_v176.segment)
        buff.write(_struct_I.pack(length))
        for val3 in _v176.segment:
          _v177 = val3.line_segment
          length = len(_v177.point)
          buff.write(_struct_I.pack(length))
          for val5 in _v177.point:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v178 = val3.arc
          _v179 = _v178.center
          _x = _v179
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v178
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v180 = val3.spiral
          _x = _v180
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v181 = val3.spline
          _x = _v181
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v181.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(_v181.knot.tostring())
          length = len(_v181.control)
          buff.write(_struct_I.pack(length))
          for val5 in _v181.control:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v182 = val3.poly3
          pass
          buff.write(_struct_d.pack(val3.s))
          _v183 = val3.start_position
          _x = _v183
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val3
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _v184 = val1.location
        _x = _v184
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        _v185 = val1.signal_id
        buff.write(_struct_b.pack(_v185.id))
      length = len(self.signal)
      buff.write(_struct_I.pack(length))
      for val1 in self.signal:
        _v186 = val1.id
        buff.write(_struct_b.pack(_v186.id))
        _v187 = val1.boundary
        length = len(_v187.point)
        buff.write(_struct_I.pack(length))
        for val3 in _v187.point:
          _x = val3
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.subsignal)
        buff.write(_struct_I.pack(length))
        for val2 in val1.subsignal:
          _v188 = val2.id
          buff.write(_struct_b.pack(_v188.id))
          buff.write(_struct_i.pack(val2.type))
          _v189 = val2.location
          _x = _v189
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
        buff.write(_struct_i.pack(val1.type))
        length = len(val1.stop_line)
        buff.write(_struct_I.pack(length))
        for val2 in val1.stop_line:
          length = len(val2.segment)
          buff.write(_struct_I.pack(length))
          for val3 in val2.segment:
            _v190 = val3.line_segment
            length = len(_v190.point)
            buff.write(_struct_I.pack(length))
            for val5 in _v190.point:
              _x = val5
              buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v191 = val3.arc
            _v192 = _v191.center
            _x = _v192
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _x = _v191
            buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
            _v193 = val3.spiral
            _x = _v193
            buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
            _v194 = val3.spline
            _x = _v194
            buff.write(_struct_2i.pack(_x.dimension, _x.degree))
            length = len(_v194.knot)
            buff.write(_struct_I.pack(length))
            pattern = '<%sd'%length
            buff.write(_v194.knot.tostring())
            length = len(_v194.control)
            buff.write(_struct_I.pack(length))
            for val5 in _v194.control:
              _x = val5
              buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _v195 = val3.poly3
            pass
            buff.write(_struct_d.pack(val3.s))
            _v196 = val3.start_position
            _x = _v196
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
            _x = val3
            buff.write(_struct_2d.pack(_x.heading, _x.length))
      length = len(self.yieldX)
      buff.write(_struct_I.pack(length))
      for val1 in self.yieldX:
        _v197 = val1.id
        buff.write(_struct_b.pack(_v197.id))
        _v198 = val1.stop_line
        length = len(_v198.segment)
        buff.write(_struct_I.pack(length))
        for val3 in _v198.segment:
          _v199 = val3.line_segment
          length = len(_v199.point)
          buff.write(_struct_I.pack(length))
          for val5 in _v199.point:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v200 = val3.arc
          _v201 = _v200.center
          _x = _v201
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = _v200
          buff.write(_struct_3d.pack(_x.radius, _x.start_angle, _x.end_angle))
          _v202 = val3.spiral
          _x = _v202
          buff.write(_struct_2d.pack(_x.curv_start, _x.curv_end))
          _v203 = val3.spline
          _x = _v203
          buff.write(_struct_2i.pack(_x.dimension, _x.degree))
          length = len(_v203.knot)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(_v203.knot.tostring())
          length = len(_v203.control)
          buff.write(_struct_I.pack(length))
          for val5 in _v203.control:
            _x = val5
            buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _v204 = val3.poly3
          pass
          buff.write(_struct_d.pack(val3.s))
          _v205 = val3.start_position
          _x = _v205
          buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
          _x = val3
          buff.write(_struct_2d.pack(_x.heading, _x.length))
        _v206 = val1.location
        _x = _v206
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        length = len(val1.overlap_id)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlap_id:
          buff.write(_struct_b.pack(val2.id))
      length = len(self.overlap)
      buff.write(_struct_I.pack(length))
      for val1 in self.overlap:
        _v207 = val1.id
        buff.write(_struct_b.pack(_v207.id))
        length = len(val1.object)
        buff.write(_struct_I.pack(length))
        for val2 in val1.object:
          _v208 = val2.id
          buff.write(_struct_b.pack(_v208.id))
          _v209 = val2.lane_overlap_info
          _x = _v209
          buff.write(_struct_2d2B.pack(_x.start_s, _x.end_s, _x.is_merge, _x.has_precedence))
          _v210 = val2.signal_overlap_info
          pass
          _v211 = val2.stop_sign_overlap_info
          pass
          _v212 = val2.crosswalk_overlap_info
          pass
          _v213 = val2.junction_overlap_info
          pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = hdmap_pb_msgs.msg.Header()
      if self.crosswalk is None:
        self.crosswalk = None
      if self.junction is None:
        self.junction = None
      if self.lane is None:
        self.lane = None
      if self.stop_sign is None:
        self.stop_sign = None
      if self.signal is None:
        self.signal = None
      if self.yieldX is None:
        self.yieldX = None
      if self.overlap is None:
        self.overlap = None
      end = 0
      _x = self
      start = end
      end += 2
      (_x.header.version, _x.header.date,) = _struct_2b.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.crosswalk = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Crosswalk()
        _v214 = val1.id
        start = end
        end += 1
        (_v214.id,) = _struct_b.unpack(str[start:end])
        _v215 = val1.polygon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v215.point = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.Point()
          _x = val3
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v215.point.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        self.crosswalk.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.junction = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Junction()
        _v216 = val1.id
        start = end
        end += 1
        (_v216.id,) = _struct_b.unpack(str[start:end])
        _v217 = val1.polygon
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v217.point = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.Point()
          _x = val3
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v217.point.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.crosswalk_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.crosswalk_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        start = end
        end += 4
        (val1.num_road_segments,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.lane_id.append(val2)
        self.junction.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Lane()
        _v218 = val1.id
        start = end
        end += 1
        (_v218.id,) = _struct_b.unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.type, _x.turn,) = _struct_2i.unpack(str[start:end])
        _v219 = val1.central_curve
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v219.segment = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.CurveSegment()
          _v220 = val3.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v220.point = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v220.point.append(val5)
          _v221 = val3.arc
          _v222 = _v221.center
          _x = _v222
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v221
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v223 = val3.spiral
          _x = _v223
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v224 = val3.spline
          _x = _v224
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v224.knot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v224.control = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v224.control.append(val5)
          _v225 = val3.poly3
          start = end
          end += 8
          (val3.s,) = _struct_d.unpack(str[start:end])
          _v226 = val3.start_position
          _x = _v226
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val3
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v219.segment.append(val3)
        _v227 = val1.left_boundary
        _v228 = _v227.curve
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v228.segment = []
        for i in range(0, length):
          val4 = hdmap_pb_msgs.msg.CurveSegment()
          _v229 = val4.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v229.point = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v229.point.append(val6)
          _v230 = val4.arc
          _v231 = _v230.center
          _x = _v231
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v230
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v232 = val4.spiral
          _x = _v232
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v233 = val4.spline
          _x = _v233
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v233.knot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v233.control = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v233.control.append(val6)
          _v234 = val4.poly3
          start = end
          end += 8
          (val4.s,) = _struct_d.unpack(str[start:end])
          _v235 = val4.start_position
          _x = _v235
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val4
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v228.segment.append(val4)
        _x = _v227
        start = end
        end += 12
        (_x.type, _x.length,) = _struct_id.unpack(str[start:end])
        _v236 = val1.right_boundary
        _v237 = _v236.curve
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v237.segment = []
        for i in range(0, length):
          val4 = hdmap_pb_msgs.msg.CurveSegment()
          _v238 = val4.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v238.point = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v238.point.append(val6)
          _v239 = val4.arc
          _v240 = _v239.center
          _x = _v240
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v239
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v241 = val4.spiral
          _x = _v241
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v242 = val4.spline
          _x = _v242
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v242.knot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v242.control = []
          for i in range(0, length):
            val6 = hdmap_pb_msgs.msg.Point()
            _x = val6
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v242.control.append(val6)
          _v243 = val4.poly3
          start = end
          end += 8
          (val4.s,) = _struct_d.unpack(str[start:end])
          _v244 = val4.start_position
          _x = _v244
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val4
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v237.segment.append(val4)
        _x = _v236
        start = end
        end += 12
        (_x.type, _x.length,) = _struct_id.unpack(str[start:end])
        _x = val1
        start = end
        end += 24
        (_x.width, _x.length, _x.speed_limit,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.predecessor_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.predecessor_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.successor_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.successor_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_neighbor_forward_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.left_neighbor_forward_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_neighbor_forward_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.right_neighbor_forward_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_neighbor_reverse_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.left_neighbor_reverse_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_neighbor_reverse_lane_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.right_neighbor_reverse_lane_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.stop_sign_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.stop_sign_id.append(val2)
        _v245 = val1.junction_id
        start = end
        end += 1
        (_v245.id,) = _struct_b.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.crosswalk_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.crosswalk_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.yield_sign_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.yield_sign_id.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_sample = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.LaneSampleAssociation()
          _x = val2
          start = end
          end += 16
          (_x.s, _x.width,) = _struct_2d.unpack(str[start:end])
          val1.left_sample.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_sample = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.LaneSampleAssociation()
          _x = val2
          start = end
          end += 16
          (_x.s, _x.width,) = _struct_2d.unpack(str[start:end])
          val1.right_sample.append(val2)
        self.lane.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stop_sign = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.StopSign()
        _v246 = val1.id
        start = end
        end += 1
        (_v246.id,) = _struct_b.unpack(str[start:end])
        _v247 = val1.stop_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v247.segment = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.CurveSegment()
          _v248 = val3.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v248.point = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v248.point.append(val5)
          _v249 = val3.arc
          _v250 = _v249.center
          _x = _v250
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v249
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v251 = val3.spiral
          _x = _v251
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v252 = val3.spline
          _x = _v252
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v252.knot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v252.control = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v252.control.append(val5)
          _v253 = val3.poly3
          start = end
          end += 8
          (val3.s,) = _struct_d.unpack(str[start:end])
          _v254 = val3.start_position
          _x = _v254
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val3
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v247.segment.append(val3)
        _v255 = val1.location
        _x = _v255
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        _v256 = val1.signal_id
        start = end
        end += 1
        (_v256.id,) = _struct_b.unpack(str[start:end])
        self.stop_sign.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.signal = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Signal()
        _v257 = val1.id
        start = end
        end += 1
        (_v257.id,) = _struct_b.unpack(str[start:end])
        _v258 = val1.boundary
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v258.point = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.Point()
          _x = val3
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _v258.point.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.subsignal = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Subsignal()
          _v259 = val2.id
          start = end
          end += 1
          (_v259.id,) = _struct_b.unpack(str[start:end])
          start = end
          end += 4
          (val2.type,) = _struct_i.unpack(str[start:end])
          _v260 = val2.location
          _x = _v260
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          val1.subsignal.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        start = end
        end += 4
        (val1.type,) = _struct_i.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.stop_line = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Curve()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.segment = []
          for i in range(0, length):
            val3 = hdmap_pb_msgs.msg.CurveSegment()
            _v261 = val3.line_segment
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v261.point = []
            for i in range(0, length):
              val5 = hdmap_pb_msgs.msg.Point()
              _x = val5
              start = end
              end += 24
              (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
              _v261.point.append(val5)
            _v262 = val3.arc
            _v263 = _v262.center
            _x = _v263
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _x = _v262
            start = end
            end += 24
            (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
            _v264 = val3.spiral
            _x = _v264
            start = end
            end += 16
            (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
            _v265 = val3.spline
            _x = _v265
            start = end
            end += 8
            (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sd'%length
            start = end
            end += struct.calcsize(pattern)
            _v265.knot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            _v265.control = []
            for i in range(0, length):
              val5 = hdmap_pb_msgs.msg.Point()
              _x = val5
              start = end
              end += 24
              (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
              _v265.control.append(val5)
            _v266 = val3.poly3
            start = end
            end += 8
            (val3.s,) = _struct_d.unpack(str[start:end])
            _v267 = val3.start_position
            _x = _v267
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _x = val3
            start = end
            end += 16
            (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
            val2.segment.append(val3)
          val1.stop_line.append(val2)
        self.signal.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.yieldX = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.YieldSign()
        _v268 = val1.id
        start = end
        end += 1
        (_v268.id,) = _struct_b.unpack(str[start:end])
        _v269 = val1.stop_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v269.segment = []
        for i in range(0, length):
          val3 = hdmap_pb_msgs.msg.CurveSegment()
          _v270 = val3.line_segment
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v270.point = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v270.point.append(val5)
          _v271 = val3.arc
          _v272 = _v271.center
          _x = _v272
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = _v271
          start = end
          end += 24
          (_x.radius, _x.start_angle, _x.end_angle,) = _struct_3d.unpack(str[start:end])
          _v273 = val3.spiral
          _x = _v273
          start = end
          end += 16
          (_x.curv_start, _x.curv_end,) = _struct_2d.unpack(str[start:end])
          _v274 = val3.spline
          _x = _v274
          start = end
          end += 8
          (_x.dimension, _x.degree,) = _struct_2i.unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          end += struct.calcsize(pattern)
          _v274.knot = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v274.control = []
          for i in range(0, length):
            val5 = hdmap_pb_msgs.msg.Point()
            _x = val5
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
            _v274.control.append(val5)
          _v275 = val3.poly3
          start = end
          end += 8
          (val3.s,) = _struct_d.unpack(str[start:end])
          _v276 = val3.start_position
          _x = _v276
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
          _x = val3
          start = end
          end += 16
          (_x.heading, _x.length,) = _struct_2d.unpack(str[start:end])
          _v269.segment.append(val3)
        _v277 = val1.location
        _x = _v277
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlap_id = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.Id()
          start = end
          end += 1
          (val2.id,) = _struct_b.unpack(str[start:end])
          val1.overlap_id.append(val2)
        self.yieldX.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.overlap = []
      for i in range(0, length):
        val1 = hdmap_pb_msgs.msg.Overlap()
        _v278 = val1.id
        start = end
        end += 1
        (_v278.id,) = _struct_b.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.object = []
        for i in range(0, length):
          val2 = hdmap_pb_msgs.msg.ObjectOverlapInfo()
          _v279 = val2.id
          start = end
          end += 1
          (_v279.id,) = _struct_b.unpack(str[start:end])
          _v280 = val2.lane_overlap_info
          _x = _v280
          start = end
          end += 18
          (_x.start_s, _x.end_s, _x.is_merge, _x.has_precedence,) = _struct_2d2B.unpack(str[start:end])
          _v280.is_merge = bool(_v280.is_merge)
          _v280.has_precedence = bool(_v280.has_precedence)
          _v281 = val2.signal_overlap_info
          _v282 = val2.stop_sign_overlap_info
          _v283 = val2.crosswalk_overlap_info
          _v284 = val2.junction_overlap_info
          val1.object.append(val2)
        self.overlap.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_b = struct.Struct("<b")
_struct_d = struct.Struct("<d")
_struct_i = struct.Struct("<i")
_struct_2d2B = struct.Struct("<2d2B")
_struct_id = struct.Struct("<id")
_struct_2d = struct.Struct("<2d")
_struct_2b = struct.Struct("<2b")
_struct_2i = struct.Struct("<2i")
_struct_3d = struct.Struct("<3d")
